---
title: <해킹및바이러스>기말을 위한
category: 해킹및바이러스
---

### 해킹및바이러스

##### HelloWorld.exe 디버깅

- EP(Entry Point): 실행 시작 주소

| 이름                      | 매크로       | 설명                                            |
|--------------------------|-----------|-----------------------------------------------|
| Restart                  | [Ctrl+F2] | 처음부터 다시 디버깅 시작(현재 디버깅 프로세스를 종료하고 재실행)         |
| Step Into                | [F7]      | 하나의 OP code 실행, CALL 명령을 만나면 함수 코드 내부로 들어감    |
| Step Over                | [F8]      | 하나의 OP code 실행, CALL 명령을 만나면 함수 자체를 실행        |
| Executer till Return     | [Ctrl+F9] | 함수 코드 내에서 RETN명령어까지 실행                        |
| Go to                    | [Ctrl+G]  | 원하는 주소로 이동                                    |
| Excute till Cursor       | [F4]      | cursor 위치까지 실행                                |
| Comment                  | ;         | Comment 추가                                    |
| Lable                    | :         | Label 추가                                      |
| Set/Reset BreakPoint     | [F2]      | BP설정/해제                                       |
| Run                      | [F9]      | 실행                                            |
| Show the current EIP     | *         | 현재 EIP 위치를 보여줌                                |
| Show the previous Cursor | -         | 직전 커서 위치를 다시 보여줌                              |
| Preview Call/JMP address | [Enter]   | 커서가 CALL/JMP 등의 명령어에 위치해 있다면, 해당 주소를 따라가서 보여줌 |

- 베이스 캠프
  1. Goto 명령어 -> Execute till cursor 명령어
  2. BP 설치 -> 실행
  3. 주석
  4. 레이블
- 원하는 코드 빨리 찾아내는 4가지 방법
  1. 코드 실행 방법
     - F8로 찾아냄
  2. 문자열 검색 방법
     - Search for - All referenced text strings 명령을 사용
  3. API 검색
     1. 호출 코드에 BP
     - Search for - All intermodular calls
     2. API 코드에 BP
     - Search for - Name in all modules

### "Hello World!" 문자열 패치

- 문자열 패치
   1. 문자열 버퍼를 직접 수정
      - [Ctrl+E] 단축키로 Edit 다이얼 로그를 띄움
   2. 다른 메모리 영역에 새로운 문자열을 생성하여 전달
      - 새로운 버퍼 주소로 연결


### 리틀 엔디언

   Byte b = 0x12;   // 바이트 단위로 [12] 저장
   Word w = 0x1234; // 바이트 단위로 [34][12] 저장
   Dword dw = 0x12345678; // 바이트 단위로 [78][56][34][12] 저장
   char str[] = "abcde"; // 바이트 단위로 [a][b][c][d][e][00] 저장



빅 엔디언 : 사람이 보기에 직관적
리틀 엔디언 : 산술연산과 데이터의 타입 확장/축소될 때 더 효율적


### CPU 레지스터 

- 범용 레지스터
   - 상수, 주소 등을 저장할 때 사용
   - EAX AX AH AL
   
|레지스터 종류|레지스터 역할 |
|-----------|------------|
|EAX		|연산 후 결과 저장|
|EBX		|DS 세그먼트 내에 데이터 주소값 기억|
|ECX		| 반복 루틴 작성시 사용|
|EDX		|input,output에 대한 포인터|
|EBP		|스택베이스포인터|
|ESI		|문자열연산의 소스 주소|
|EDI		|문자열연산의 목적지주소|
|ESP		|스택포인터|


- 세그먼트 레지스터
   - IA-32 보호 모드: 세그먼트 단위로 메모리를 조각 내어, 조각마다 정보를 가지고 메모리를 보호하는 기법
   - 각 세그먼트 값은 페이징 기법과 가상 메모리를 물리메모리로 변경시 사용 (운영체제에서 했던것)

- 세그먼트 레지스터
   - 역할 Segment Descriptor Table(SDT)의 인덱스 저장
      - SDT는 각 세그먼트의 시작 주소 값이 저장
   - CS, SS, DS, ES, FS, GS 총 6개의 16비트 레지스터

- EFLAGS: flag register
   - 각 비트마다 0또는 1의 값을 가지며 의미가 있음
   - ZF(Zero flag): 연산 명령 후 결과 값이 0일 경우 1로 세팅
   - OF(Overflow flag): 오버플로가 발생했을 때, MSB가 변경되었을 때 1로 세팅
   - CF(Carry flag): 부호 없는 수 의 오버플로가 발생했을 때 1로 세팅

- EIP: CPU가 처리할 명령어의 주소를 나타내며, 저장된 메모리 주소의 명령어를 하나 처리하고 난 후 자동으로 그 명령어 길이만큼 EIP 증가