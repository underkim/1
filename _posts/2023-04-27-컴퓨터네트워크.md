---
title: "<컴퓨터네트워크> 기말을 위한 "

tags: study
  
toc: true

date: 2023-04-27
---

# 컴퓨터네트워크
***

## 트랜스포츠 계층의 정의
  -  프로세스를 구분
  - 신뢰성 있는 서비스 제공 
    - 오류제어, 흐름제어, 혼잡제어


### 9.1   Transport-Layer Services
- 트랜스포트 계층 : 응용층에 서비스 제공
- Process-to-Process
  - Process : 돌아가는 프로그램 (응용층의 객체)
  - entity: 객체 (지구상에 유일하게 구분되는 물체)

- **Port Number** : 포트번호
  - 통신을 시작하고 요청하는 것 : 클라이언트
  - 통신 요청에 응답 : 서버
  - 클라이언트와 서버의 패러다임이 존재함 (client-server paradigm)

![img](https://user-images.githubusercontent.com/51310308/236840165-c9631c63-1d4e-4369-b10b-28ea568f2555.png)

-  Data link - MAC address/HW address/Phy address
-  Network – IP address/Logical address
-  Transport – port number/SAP

- <mark>포트번호는 16bit으로 구성되어있다.</mark>
- <mark>서버는 대부분 well-known (permanent) port numbers</mark>
- <mark>잘 알려져있어야 통신 가능하다.</mark>


#### Socket address
![img_1](https://user-images.githubusercontent.com/51310308/236840178-c81a8c03-df53-4e97-9a16-58bdb8be9c7f.png)
<mark>IP와 포트번호 사이의 연결이 필요하다.</mark>

#### Encapsulation and Decapsulation
 
 응용층 데이터 -> 전송층 데이터 | 전송층 데이터 -> 응용층 데이터

#### Flow Control
- production과 consumption 사이의 균형
- 너무 빠르게 주면 데이터가 전송 다못함
- 너무 느리게 주면 효율이 안 좋음
- 응용층과 전송층 사이에서 관계 (pushing and pulling)
  - pushing: 보내는 놈이 갑
    - 받는놈이 너무 많이 받으면 흐름제어 요청<br>
      응용층 -> 전송층 | 전송층 -> 전송층
  - pulling: 받는놈이 갑
    - 데이터를 달라고 요청하면 보내는 놈이 데이터 전송<br>
      응용층 <- 전송층 | 전송층 -> 전송층

#### 오류제어
- 보내는 쪽은 보내기만함
- 받는 쪽에서 오류를 확인함
- 오류제어: 상대방이 제대로 받을때까지
  - 시퀀스 번호 필요
    - 용도: 패킷이 오류가 있는지 응답
  - ACK 필요
    - 용도: 제대로 받았는지 응답
  - 보내는쪽의 타이머 필요
    - 용도: 시간이 지나도 응답이 없으면 재전송

#### Sliding window
![img_2](https://user-images.githubusercontent.com/51310308/236840196-86435524-3951-4e99-b5c5-68302bc51f46.png)
<span style="background-color:#FFE6E6">오류 제어와 흐름 제어를 한번에 해결하기 위한 방법</span>

- window: 보이는 부분
  - size 가 크면 보낼 수 있는 양 증가 (흐름제어)
- 확답을 받을 때까지 window가 오른쪽으로 이동하지 않음(오류제어)


#### 혼잡제어
 <span style="background-color:#FFE6E6">네트워크 상의 데이터 처리 </span>

#### connectionless
- 각 각의 패킷이 독립적으로 처리됨
#### connection-oriented
- 패킷이 연결됨
- 연결설정하는 단계가 필요
- 데이터 전송 후 연결을 끊어야됨

***

#### FSM : 파이널 스테이트 머신

#### 오류제어를 위한 3가지 방법론
- Simple Protocol
  - 절대로 존재할수없는 상황
    - 오류 X 흐름문제 X 경우

- Stop-and-Wait Protocol
  - 흐름과 오류 제어
  - 시퀀스 번호, 체크썸 을 붙여 보냄
    - 수신단에서 잘 받았으면 ACK 를 보냄
    - ACK는 ACK넘버와 체크썸으로 구성
  - 작동방식 : 하나를 보내고 ACK가 올때까지 기다림
    - 보내는쪽과 받는쪽의 window size는 1 이다.
  - 약자로 SAW, 시퀀스 번호는 0 ~ 1
  - 시퀀스 번호는 중복 검출을 위해 필요하다.
  - ACK 번호는 5를 받았으면 6을 보냄

- Go-Back-N Protocol
  - 하나씩 받음
  - 순서가 절대로 뒤바뀔일이 없음
  - 장점: 보내는 쪽의 여유가 있음, 순서
  - 단점: 응답 실패시 다시 N 부터 보냄

- Selective-Repeat Protocol
  - 잘못받은것만 재전송
  - 받은것에 대한 번호로 ACK 번호를 보냄
  - 받은 쪽과 보내는 쪽 windows size가 같다.


- Piggybacking
  - 시퀀스번호와 ack번호를 동시에 보냄





****
# 임시


## TCP 
- SR을 기본으로함
- ACK를 보내는데 GBN ... 처럼 보냄
- 흐름제어 오류제어 하는것
- ACK 생성 규칙
  1. piggibacking
  2. 안되면 기다려 (2번에 대한 예외 규정 (3,4,5,6))
  3. 2개 에 대해 보내야하면 빨리 보내라
  4. 순서가 뒤바뀌면 ACK를 빨리 보내라
  5. Missing segment 가 오면 ACK segment를 빨리 보내라
  6. ACK가 사라지면 빨리 보내라



- TCP 혼잡제어
  - 혼잡은 어디서 일어나느냐?
    - 네트워크 
    - 라우터와 스위치에서 QUEUE 때문에 일어난다.
    - 혼잡은 <makr>네트워크 계층</mark>에서 일어난다.
  - TCP 혼잡제어는 <mark>미리 조심하기</mark>

  1. Taho TCP
     - 일단 버퍼링을 함
     - 패킷이 INPUT버퍼로 들어옴
     - CPU가 하나씩 처리
     - 혼잡 = 처리속도 < 데이터가 들어오는 속도
     - 받는쪽 뿐만아니라 네트워크의 혼잡에 따라 보내는쪽의 윈도우 결정
     - rwnd 와 cwnd 중에 작은것으로 보내는쪽의 윈도우 결정 
     - TCP가 혼잡이 발생했다 : 시간초과, 세개의 중복된 ACK (세그먼트가 사라졌다는 뜻)
     - TCP 혼잡제어 방법
       1. slow start
          - cwnd를 정할때 MSS를 정의
          - ACK를 받으면 window size의 반정도를 threshold로 정하고 congestion window를 1씩 증가
          - cwnd -> 혼잡에 대한 정보 -> 아주 작은 값으로 시작(미리조심)
          - ACK를 받을때마다 cwnd 1씩 증가
          - ssthresh 를 cwnd 절반 으로 하고 cwnd 를 1로 설정
       2. congestion avoidance
          - 혼잡 회피
          - ACK를 cwnd개 받으면 cwnd 1증가
          - <mark> Taho 그림 시험문제 </mark>
       3. fast recovery
  2. Reno TCP (가장 많이 씀)
     - Taho는 극단적 -> Reno 제작

**요약** 혼잡을 제어하겠다.<br>
조심하겠다<br>
이상입니다. <br>

## SCTP



****


































